<!DOCTYPE html>
<html lang="en-us">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		
		
		
		<meta name="generator" content="Hugo 0.58.3" />
		<title>Lock Free Linked List &middot; Bad with names</title>
		<link rel="shortcut icon" href="https://ananduee.github.io/images/favicon.ico">
		<link rel="stylesheet" href="https://ananduee.github.io/css/style.css">
		<link rel="stylesheet" href="https://ananduee.github.io/css/highlight.css">

		
		<link rel="stylesheet" href="https://ananduee.github.io/css/monosocialiconsfont.css">
		

		

		
	</head>

    <body>
       <nav class="main-nav">
	
	
		<a href='https://ananduee.github.io/'> <span class="arrow">←</span>Home</a>
	
	<a href='https://ananduee.github.io/posts'>Archive</a>
	<a href='https://ananduee.github.io/tags'>Tags</a>
	<a href='https://ananduee.github.io/about'>About</a>

	

	
</nav>


        <section id="wrapper" class="post">
            <article>
                <header>
                    <h1>
                        Lock Free Linked List
                    </h1>
                    <h2 class="headline">
                    Oct 27, 2019 14:09
                    · 2101 words
                    · 10 minute read
                      <span class="tags">
                      
                      </span>
                    </h2>
                </header>
                
                <section id="post-body">
                    

<p>This is my first blog post. Through this blog I want to learn and explore different paradigms of programming and software development. So this blog will mostly be in format of notes of things which I have read and some of my thoughts around them. I will try to ensure that I always metion links which I have used to research on the topic.</p>

<p>On of my personal favuorite paradigms in programming is asynchronous programming so wanted to start with a very basic lock free data structure &ldquo;Lock free linked list&rdquo;.</p>

<h3 id="what-does-lock-free-programming-mean">What does lock free programming mean ?</h3>

<p>Let&rsquo;s say we have some data which others can be read as well as change. Depending on the methods we provide to change the data we might leave data in in-consistent state. for example :-</p>

<p>Let&rsquo;s say we have a variable <code>int value = 0</code> and we provide a method to increment this value. Here is how basic implementation of &ldquo;increment&rdquo; method would look :-</p>

<pre><code class="language-java">void increment() {
    value = value + 1;
}
</code></pre>

<p>Till time this method gets called from one thread everything will work fine. Now lets say multiple threads start calling this method increment in parallel. Here is java code to do so :-</p>

<pre><code class="language-java">import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

class IncrementTesting
{
    public static int value = 0;

    public static void main (String[] args) throws java.lang.Exception
    {
        final int loopSize = 10000; // You can change loop size to experiment.
        // Ensure you use more than 1 thread.
        final ExecutorService executor = Executors.newFixedThreadPool(2); 
        final CompletableFuture&lt;Integer&gt;[] workerTasks = new CompletableFuture[loopSize];
        for (int i = 0; i &lt; loopSize; ++i) {
            // Start work asynchronously.
            workerTasks[i] = CompletableFuture.supplyAsync(() -&gt; increment(), executor); 
        }
        // Wait for all async tasks to finish.
        CompletableFuture.allOf(workerTasks).join();
        System.out.println(value);
        executor.shutdown();
    }

    private static int increment() {
        value = value + 1;
        return value;
    }
}
</code></pre>

<p>We would expect this programm to print &ldquo;10000&rdquo;, However here is output of this programme on my laptop :-</p>

<ol>
<li>Run number 1 - 9994</li>
<li>Run number 2 - 9992</li>
<li>Run umber 3 - 9997</li>
<li>Run number 4 - 9998</li>
</ol>

<p>In fact every run will give you a different output in some runs you can even get the desired &ldquo;10000&rdquo; value. If we see following are the things which are happening in method increment :-</p>

<ol>
<li>Read the current value.</li>
<li>Increase the value by one</li>
<li>Set this value to existing variable.</li>
</ol>

<p>If multiple threads are performing this action in parallel it might happen that a thread 1 (T1) has read the value and wants to increase it now another thread T2 reads this value before T1 fnishes setting the value in such cases value won&rsquo;t be incremneted in T2 as it has previous value.</p>

<p>Traditional way to solve this problem is by using locks. In java we can just make the method &ldquo;increment&rdquo; <a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/locksync.html">synchronized</a>. This will ensure this method can only be called by one thread at a time. If multiple threads want to invoke this method they will automatically wait for this method to finish for active thread.</p>

<p>However locks/synchronization have a cost. In the above example second thread will always have to wait for first thread to finish this effectively means that their is not advantage of using multiple threads.</p>

<p>So general idea of lock free programming is - Minimize usage of locks by using <a href="https://en.wikipedia.org/wiki/Optimistic_concurrency_control">optimistic design</a>, <a href="https://en.wikipedia.org/wiki/Compare-and-swap">CAS</a> etc. We can never eliminate locks fully as lock free programming poses certain limitations on how a programme can be written.</p>

<h3 id="compare-and-swap-cas">Compare and swap (CAS)</h3>

<p>As per wikipedia &ldquo;CAS compares the contents of a memory location with a given value and, only if they are the same, modifies the contents of that memory location to a new given value.&rdquo;. Most of modern CPU&rsquo;s support this operation by default i.e. In 1 operation you can compare value in a memory location and if found equal change it to a new value.</p>

<p>Java provides this through &ldquo;AtomicInteger&rdquo;, &ldquo;AtomicBoolean&rdquo;, &ldquo;AtomicLong&rdquo; etc classes. If you look at &ldquo;compareAndSet&rdquo; method inside &ldquo;AtomicInteger&rdquo; it is calling &ldquo;Unsafe&rdquo; class of java to hardware specific operation.</p>

<p>Here is how are programme would look with compare and swap operation</p>

<pre><code class="language-java">import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicInteger;

/* Name of the class has to be &quot;Main&quot; only if the class is public. */
class Ideone
{
    public static AtomicInteger value = new AtomicInteger(0);

    public static void main (String[] args) throws java.lang.Exception
    {
        final int loopSize = 10000; // You can change loop size to experiment.
        final ExecutorService executor = Executors.newFixedThreadPool(10);
        final CompletableFuture&lt;Integer&gt;[] workerTasks = new CompletableFuture[loopSize];
        for (int i = 0; i &lt; loopSize; ++i) {
            workerTasks[i] = CompletableFuture.supplyAsync(() -&gt; increment(), executor); // Start work asynchronously.
        }
        CompletableFuture.allOf(workerTasks).join(); // Wait for all async tasks to finish.
        System.out.println(value);
        executor.shutdown();
    }

    private static int increment() {
        int currentValue = value.intValue();
        while (!value.compareAndSet(currentValue, currentValue + 1)) {
            currentValue = value.intValue();
        }
        return currentValue;
    }
}
</code></pre>

<p>The only thing which has changed here is that we used &ldquo;AtomicIntger&rdquo; instead of primitive &ldquo;int&rdquo; which provides us atomic compare and set operation. We then assign value on which we want to increment in a seperate variable and loop till our desired value is set.</p>

<p>Good thing here is that none of the threads will be blocked so their is no deadlock scenario to worry about.</p>

<h3 id="linked-list">Linked list</h3>

<p>To allow arbitary insertion we will implement a sorted linked list this implemention can be easily modifed to create a normal linked list/stack/queue. Let&rsquo;s assume following structure of Node in the linked list :-</p>

<pre><code class="language-java">class Node {
    int value;
    Node next;
}
</code></pre>

<p>Let&rsquo;s consider an ordered linked list :-</p>

<pre><code class="language-no-highlight">+----------+    +-------+    +-------+   +-------+    +--------+
|   head   ------   1   ------  3    -----   7   ------  tail  |
+----------+    +-------+    +-------+   +-------+    +--------+                                                           
</code></pre>

<p>In such a list insertion requires finding postion of the node i.e node after which this node should be inserted. Let&rsquo;s say we want to insert 5 in this list. It will require two operations making 7 as next node of 5 and then changing next node of 3 to 5.</p>

<p>Operation 1 :-</p>

<pre><code class="language-no-highlight">+----------+    +-------+    +-------+           +-------+      +--------+
|   head   ------   1   ------  3    -------------   7   --------   tail |
+----------+    +-------+    +-------+          /+-------+      +--------+
                                               /                          
                                              /                           
                                             /                            
                                            /                             
                                  +-------+/                              
                                  |   5   /                               
                                  +-------+                                 
</code></pre>

<p>Operation 2 :-</p>

<pre><code class="language-no-highlight">+----------+    +-------+    +-------+ +-------+   +-------+    +--------+
|   head   ------   1   ------  3    ---  5    ----- 7     ------   tail |
+----------+    +-------+    +-------+ +-------+   +-------+    +--------+
</code></pre>

<p>Operation 1 is safe and simple and can be done directly. for Operation 2 we will need to use Compare and swap to change next of 3. CAS will ensure that swap only suceeds if next node of 3 is still 5 in case another insertion has happened i.e 6 has been inserted in parallel during next CAS attempt we will mark 6 as next node 5. This will keep on going till CAS is not successful.</p>

<p>Similarly if we think of delete operation i.e we need to delete &ldquo;5&rdquo; then we need to find node before the node to delete which would be &ldquo;3&rdquo; and change the value of next to &ldquo;7&rdquo;. We will need to ensure CAS for this operation too. Here CAS will ensure that next node of &ldquo;3&rdquo; remains &ldquo;5&rdquo; before we commit. Let&rsquo;s say while this deletion was happening their is another parallel insert between &ldquo;5&rdquo; and &ldquo;7&rdquo;. In this case a single CAS while deletion will not be enough as it will be succesfull. So single CAS can not detect that a parallel insertion and deletion operation is happening at a node.</p>

<p>Algorithm proposeed in Tim harris paper handles this case using two CAS operaations first one to mark node which will be deleted and second CAS operation to actually change the next node. After first operation node is said to be logically deleted and after second operation node is said to be physically deleted.</p>

<p>Following is code for this.</p>

<pre><code class="language-java">import java.util.concurrent.atomic.AtomicMarkableReference;

/**
 * Node represents single item in linked list. Here next pointer is atomic markable reference so that it can hold
 * additional boolean value if a node is logically deleted.
 *
 * one thing to note here is if next pointer is marked to true then it means current Node has been logically deleted.
 */
class Node {
    int value;
    AtomicMarkableReference&lt;Node&gt; next;

    public Node(int value) {
        this.value = value;
        this.next = new AtomicMarkableReference&lt;&gt;(null, false);
    }
}

/**
 * utility object used for performing search operation on the list. This object will not be exposed outside this class.
 * for a given search operation following would be values of 2 fields of this object :-
 * 1. curr - first node with equal or greater value than search keyword.
 * 2. pred - previous node of curr.
 */
class Window {
    public Node pred;
    public Node curr;

    Window(Node pred, Node curr) {
        this.pred = pred;
        this.curr = curr;
    }
}

public class LinkedList {

    Node head;
    Node tail;

    public LinkedList() {
        head = new Node(Integer.MIN_VALUE);
        tail = new Node(Integer.MAX_VALUE);
        head.next.set(tail, false);
    }

    /**
     * Add a new element to linked list.
     * @param value - value to add.
     * @return - return false in case value is already present in list in such case insertion will be ignored. Else
     * return true is value was inserted.
     */
    public boolean add(int value) {
        while (true) {
            final Window window = find(value);
            // return false if value is already present.
            if (window.curr.value == value) {
                return false;
            } else {
                final Node newNode = new Node(value);
                newNode.next = new AtomicMarkableReference&lt;&gt;(window.curr, false);

                // Try setting next node of pred using CAS operation. In case CAS operation fails we will need to find
                // new window.
                if (window.pred.next.compareAndSet(window.curr, newNode, false, false)) {
                    return true;
                }
            }
        }
    }

    /**
     * Remove an element from linked list.
     *
     * @param value - value to remove.
     * @return - return true in case value was present in list and remove. return false in case value was not present
     * in list.
     */
    public boolean remove(int value) {
        while (true) {
            final Window window = find(value);

            // in case value is not present in the list return false.
            if (window.curr.value != value) {
                return false;
            } else {
                final Node next = window.curr.next.getReference();

                // try to logically delete the node by marking delete bit to true.
                boolean logicallyDeleted = window.curr.next.attemptMark(next, true);

                // If logical deletion failed i.e someone already changed the next node try to search again.
                if (!logicallyDeleted) {
                    continue;
                }

                // physically delete the node. Even if this operation fails we are okay because we are physically
                // deleting the node during find operation anyways.
                window.pred.next.compareAndSet(window.curr, next, false, false);
                return true;
            }
        }
    }

    /**
     * utility method to print the list.
     */
    public void debug() {
        Node next = head.next.getReference();
        final StringBuilder message = new StringBuilder(&quot;head -&gt; &quot;);
        while (next != tail) {
            message.append(next.value ).append(&quot; -&gt; &quot;);
            next = next.next.getReference();
        }
        System.out.println(message.append(&quot;tail&quot;).toString());
    }

    /**
     * Method to find first node whose value is greater than or equal to value. This will return object with two
     * properties :-
     *
     * 1. curr - This represents first node whose value is greater than or equal to input.
     * 2. pred - This is previous node of curr.
     *
     * With the following definition our search operation will always return some value as out tail is initialized with
     * MaxInt which will be always greater than any input.
     *
     * @param value - keyword to search
     * @return - window object.
     */
    private Window find(int value) {
        // In case list is empty.
        if (head.next.getReference() == tail) {
            return new Window(head, tail);
        }

        Node pred = null;
        Node current = null;
        Node succ = null;

        // default status of deleted bit.
        boolean[] deleteBit = {false};

        retry:
        while (true) {
            pred = head;
            current = pred.next.getReference();

            while (true) {
                // if successor is in logical deletion deleteBit will be set to &quot;true&quot; else it will remain &quot;false&quot;.
                succ = current.next.get(deleteBit);

                // if node is logically deleted we should attempt to physically delete it.
                while (deleteBit[0]) {
                    boolean valueChanged = pred.next.compareAndSet(current, succ, false, false);
                    // If physical deletion failed this means another operation is happening in parallel. Start the loop
                    // again.
                    if (!valueChanged) {
                        continue retry;
                    }

                    // If physical deletion was successful change to next value.
                    current = succ;
                    succ = current.next.get(deleteBit);
                }

                if (current.value &gt;= value) {
                    return new Window(pred, current);
                }

                // search next node
                pred = current;
                current = succ;
            }
        }
    }

}
</code></pre>

<p>I have tried adding as many comment as possible to make it easy to understand.</p>

<h3 id="references">References</h3>

<ol>
<li><a href="https://timharris.uk/papers/2001-disc.pdf">https://timharris.uk/papers/2001-disc.pdf</a> - Main paper upon which whole article is based (highly recommended)</li>
<li><a href="https://www.cs.cmu.edu/~410-s05/lectures/L31_LockFree.pdf">https://www.cs.cmu.edu/~410-s05/lectures/L31_LockFree.pdf</a></li>
<li><a href="http://15418.courses.cs.cmu.edu/spring2013/article/46">http://15418.courses.cs.cmu.edu/spring2013/article/46</a></li>
<li><a href="https://en.wikipedia.org/wiki/Non-blocking_linked_list">https://en.wikipedia.org/wiki/Non-blocking_linked_list</a></li>
<li><a href="https://en.wikipedia.org/wiki/Compare-and-swap">https://en.wikipedia.org/wiki/Compare-and-swap</a></li>
</ol>

                </section>
            </article>

            

            

            

            <footer id="footer">
    
    <p class="small">
    
       © Copyright 2019 <i class="fa fa-heart" aria-hidden="true"></i> 
    
    </p>
    <p class="small">
        Powered by <a href="http://www.gohugo.io/">Hugo</a> Theme By <a href="https://github.com/nodejh/hugo-theme-cactus-plus">nodejh</a>
    </p>
</footer>

        </section>

        <script src="https://ananduee.github.io/js/jquery-3.3.1.min.js"></script>
<script src="https://ananduee.github.io/js/main.js"></script>
<script src="https://ananduee.github.io/js/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>







    </body>
</html>
